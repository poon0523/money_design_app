{"ast":null,"code":"/*!\n * jQuery UI Effects 1.13.3\n * https://jqueryui.com\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license.\n * https://jquery.org/license\n */\n\n//>>label: Effects Core\n//>>group: Effects\n/* eslint-disable max-len */\n//>>description: Extends the internal jQuery effects. Includes morphing and easing. Required by all other effects.\n/* eslint-enable max-len */\n//>>docs: https://api.jqueryui.com/category/effects-core/\n//>>demos: https://jqueryui.com/effect/\n\n(function (factory) {\n  \"use strict\";\n\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([\"jquery\", \"./jquery-var-for-color\", \"./vendor/jquery-color/jquery.color\", \"./version\"], factory);\n  } else {\n    // Browser globals\n    factory(jQuery);\n  }\n})(function ($) {\n  \"use strict\";\n\n  var dataSpace = \"ui-effects-\",\n    dataSpaceStyle = \"ui-effects-style\",\n    dataSpaceAnimated = \"ui-effects-animated\";\n  $.effects = {\n    effect: {}\n  };\n\n  /******************************************************************************/\n  /****************************** CLASS ANIMATIONS ******************************/\n  /******************************************************************************/\n  (function () {\n    var classAnimationActions = [\"add\", \"remove\", \"toggle\"],\n      shorthandStyles = {\n        border: 1,\n        borderBottom: 1,\n        borderColor: 1,\n        borderLeft: 1,\n        borderRight: 1,\n        borderTop: 1,\n        borderWidth: 1,\n        margin: 1,\n        padding: 1\n      };\n    $.each([\"borderLeftStyle\", \"borderRightStyle\", \"borderBottomStyle\", \"borderTopStyle\"], function (_, prop) {\n      $.fx.step[prop] = function (fx) {\n        if (fx.end !== \"none\" && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {\n          jQuery.style(fx.elem, prop, fx.end);\n          fx.setAttr = true;\n        }\n      };\n    });\n    function camelCase(string) {\n      return string.replace(/-([\\da-z])/gi, function (all, letter) {\n        return letter.toUpperCase();\n      });\n    }\n    function getElementStyles(elem) {\n      var key,\n        len,\n        style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : elem.currentStyle,\n        styles = {};\n      if (style && style.length && style[0] && style[style[0]]) {\n        len = style.length;\n        while (len--) {\n          key = style[len];\n          if (typeof style[key] === \"string\") {\n            styles[camelCase(key)] = style[key];\n          }\n        }\n\n        // Support: Opera, IE <9\n      } else {\n        for (key in style) {\n          if (typeof style[key] === \"string\") {\n            styles[key] = style[key];\n          }\n        }\n      }\n      return styles;\n    }\n    function styleDifference(oldStyle, newStyle) {\n      var diff = {},\n        name,\n        value;\n      for (name in newStyle) {\n        value = newStyle[name];\n        if (oldStyle[name] !== value) {\n          if (!shorthandStyles[name]) {\n            if ($.fx.step[name] || !isNaN(parseFloat(value))) {\n              diff[name] = value;\n            }\n          }\n        }\n      }\n      return diff;\n    }\n\n    // Support: jQuery <1.8\n    if (!$.fn.addBack) {\n      $.fn.addBack = function (selector) {\n        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n      };\n    }\n    $.effects.animateClass = function (value, duration, easing, callback) {\n      var o = $.speed(duration, easing, callback);\n      return this.queue(function () {\n        var animated = $(this),\n          baseClass = animated.attr(\"class\") || \"\",\n          applyClassChange,\n          allAnimations = o.children ? animated.find(\"*\").addBack() : animated;\n\n        // Map the animated objects to store the original styles.\n        allAnimations = allAnimations.map(function () {\n          var el = $(this);\n          return {\n            el: el,\n            start: getElementStyles(this)\n          };\n        });\n\n        // Apply class change\n        applyClassChange = function () {\n          $.each(classAnimationActions, function (i, action) {\n            if (value[action]) {\n              animated[action + \"Class\"](value[action]);\n            }\n          });\n        };\n        applyClassChange();\n\n        // Map all animated objects again - calculate new styles and diff\n        allAnimations = allAnimations.map(function () {\n          this.end = getElementStyles(this.el[0]);\n          this.diff = styleDifference(this.start, this.end);\n          return this;\n        });\n\n        // Apply original class\n        animated.attr(\"class\", baseClass);\n\n        // Map all animated objects again - this time collecting a promise\n        allAnimations = allAnimations.map(function () {\n          var styleInfo = this,\n            dfd = $.Deferred(),\n            opts = $.extend({}, o, {\n              queue: false,\n              complete: function () {\n                dfd.resolve(styleInfo);\n              }\n            });\n          this.el.animate(this.diff, opts);\n          return dfd.promise();\n        });\n\n        // Once all animations have completed:\n        $.when.apply($, allAnimations.get()).done(function () {\n          // Set the final class\n          applyClassChange();\n\n          // For each animated element,\n          // clear all css properties that were animated\n          $.each(arguments, function () {\n            var el = this.el;\n            $.each(this.diff, function (key) {\n              el.css(key, \"\");\n            });\n          });\n\n          // This is guarnteed to be there if you use jQuery.speed()\n          // it also handles dequeuing the next anim...\n          o.complete.call(animated[0]);\n        });\n      });\n    };\n    $.fn.extend({\n      addClass: function (orig) {\n        return function (classNames, speed, easing, callback) {\n          return speed ? $.effects.animateClass.call(this, {\n            add: classNames\n          }, speed, easing, callback) : orig.apply(this, arguments);\n        };\n      }($.fn.addClass),\n      removeClass: function (orig) {\n        return function (classNames, speed, easing, callback) {\n          return arguments.length > 1 ? $.effects.animateClass.call(this, {\n            remove: classNames\n          }, speed, easing, callback) : orig.apply(this, arguments);\n        };\n      }($.fn.removeClass),\n      toggleClass: function (orig) {\n        return function (classNames, force, speed, easing, callback) {\n          if (typeof force === \"boolean\" || force === undefined) {\n            if (!speed) {\n              // Without speed parameter\n              return orig.apply(this, arguments);\n            } else {\n              return $.effects.animateClass.call(this, force ? {\n                add: classNames\n              } : {\n                remove: classNames\n              }, speed, easing, callback);\n            }\n          } else {\n            // Without force parameter\n            return $.effects.animateClass.call(this, {\n              toggle: classNames\n            }, force, speed, easing);\n          }\n        };\n      }($.fn.toggleClass),\n      switchClass: function (remove, add, speed, easing, callback) {\n        return $.effects.animateClass.call(this, {\n          add: add,\n          remove: remove\n        }, speed, easing, callback);\n      }\n    });\n  })();\n\n  /******************************************************************************/\n  /*********************************** EFFECTS **********************************/\n  /******************************************************************************/\n\n  (function () {\n    if ($.expr && $.expr.pseudos && $.expr.pseudos.animated) {\n      $.expr.pseudos.animated = function (orig) {\n        return function (elem) {\n          return !!$(elem).data(dataSpaceAnimated) || orig(elem);\n        };\n      }($.expr.pseudos.animated);\n    }\n    if ($.uiBackCompat !== false) {\n      $.extend($.effects, {\n        // Saves a set of properties in a data storage\n        save: function (element, set) {\n          var i = 0,\n            length = set.length;\n          for (; i < length; i++) {\n            if (set[i] !== null) {\n              element.data(dataSpace + set[i], element[0].style[set[i]]);\n            }\n          }\n        },\n        // Restores a set of previously saved properties from a data storage\n        restore: function (element, set) {\n          var val,\n            i = 0,\n            length = set.length;\n          for (; i < length; i++) {\n            if (set[i] !== null) {\n              val = element.data(dataSpace + set[i]);\n              element.css(set[i], val);\n            }\n          }\n        },\n        setMode: function (el, mode) {\n          if (mode === \"toggle\") {\n            mode = el.is(\":hidden\") ? \"show\" : \"hide\";\n          }\n          return mode;\n        },\n        // Wraps the element around a wrapper that copies position properties\n        createWrapper: function (element) {\n          // If the element is already wrapped, return it\n          if (element.parent().is(\".ui-effects-wrapper\")) {\n            return element.parent();\n          }\n\n          // Wrap the element\n          var props = {\n              width: element.outerWidth(true),\n              height: element.outerHeight(true),\n              \"float\": element.css(\"float\")\n            },\n            wrapper = $(\"<div></div>\").addClass(\"ui-effects-wrapper\").css({\n              fontSize: \"100%\",\n              background: \"transparent\",\n              border: \"none\",\n              margin: 0,\n              padding: 0\n            }),\n            // Store the size in case width/height are defined in % - Fixes #5245\n            size = {\n              width: element.width(),\n              height: element.height()\n            },\n            active = document.activeElement;\n\n          // Support: Firefox\n          // Firefox incorrectly exposes anonymous content\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=561664\n          try {\n            // eslint-disable-next-line no-unused-expressions\n            active.id;\n          } catch (e) {\n            active = document.body;\n          }\n          element.wrap(wrapper);\n\n          // Fixes #7595 - Elements lose focus when wrapped.\n          if (element[0] === active || $.contains(element[0], active)) {\n            $(active).trigger(\"focus\");\n          }\n\n          // Hotfix for jQuery 1.4 since some change in wrap() seems to actually\n          // lose the reference to the wrapped element\n          wrapper = element.parent();\n\n          // Transfer positioning properties to the wrapper\n          if (element.css(\"position\") === \"static\") {\n            wrapper.css({\n              position: \"relative\"\n            });\n            element.css({\n              position: \"relative\"\n            });\n          } else {\n            $.extend(props, {\n              position: element.css(\"position\"),\n              zIndex: element.css(\"z-index\")\n            });\n            $.each([\"top\", \"left\", \"bottom\", \"right\"], function (i, pos) {\n              props[pos] = element.css(pos);\n              if (isNaN(parseInt(props[pos], 10))) {\n                props[pos] = \"auto\";\n              }\n            });\n            element.css({\n              position: \"relative\",\n              top: 0,\n              left: 0,\n              right: \"auto\",\n              bottom: \"auto\"\n            });\n          }\n          element.css(size);\n          return wrapper.css(props).show();\n        },\n        removeWrapper: function (element) {\n          var active = document.activeElement;\n          if (element.parent().is(\".ui-effects-wrapper\")) {\n            element.parent().replaceWith(element);\n\n            // Fixes #7595 - Elements lose focus when wrapped.\n            if (element[0] === active || $.contains(element[0], active)) {\n              $(active).trigger(\"focus\");\n            }\n          }\n          return element;\n        }\n      });\n    }\n    $.extend($.effects, {\n      version: \"1.13.3\",\n      define: function (name, mode, effect) {\n        if (!effect) {\n          effect = mode;\n          mode = \"effect\";\n        }\n        $.effects.effect[name] = effect;\n        $.effects.effect[name].mode = mode;\n        return effect;\n      },\n      scaledDimensions: function (element, percent, direction) {\n        if (percent === 0) {\n          return {\n            height: 0,\n            width: 0,\n            outerHeight: 0,\n            outerWidth: 0\n          };\n        }\n        var x = direction !== \"horizontal\" ? (percent || 100) / 100 : 1,\n          y = direction !== \"vertical\" ? (percent || 100) / 100 : 1;\n        return {\n          height: element.height() * y,\n          width: element.width() * x,\n          outerHeight: element.outerHeight() * y,\n          outerWidth: element.outerWidth() * x\n        };\n      },\n      clipToBox: function (animation) {\n        return {\n          width: animation.clip.right - animation.clip.left,\n          height: animation.clip.bottom - animation.clip.top,\n          left: animation.clip.left,\n          top: animation.clip.top\n        };\n      },\n      // Injects recently queued functions to be first in line (after \"inprogress\")\n      unshift: function (element, queueLength, count) {\n        var queue = element.queue();\n        if (queueLength > 1) {\n          queue.splice.apply(queue, [1, 0].concat(queue.splice(queueLength, count)));\n        }\n        element.dequeue();\n      },\n      saveStyle: function (element) {\n        element.data(dataSpaceStyle, element[0].style.cssText);\n      },\n      restoreStyle: function (element) {\n        element[0].style.cssText = element.data(dataSpaceStyle) || \"\";\n        element.removeData(dataSpaceStyle);\n      },\n      mode: function (element, mode) {\n        var hidden = element.is(\":hidden\");\n        if (mode === \"toggle\") {\n          mode = hidden ? \"show\" : \"hide\";\n        }\n        if (hidden ? mode === \"hide\" : mode === \"show\") {\n          mode = \"none\";\n        }\n        return mode;\n      },\n      // Translates a [top,left] array into a baseline value\n      getBaseline: function (origin, original) {\n        var y, x;\n        switch (origin[0]) {\n          case \"top\":\n            y = 0;\n            break;\n          case \"middle\":\n            y = 0.5;\n            break;\n          case \"bottom\":\n            y = 1;\n            break;\n          default:\n            y = origin[0] / original.height;\n        }\n        switch (origin[1]) {\n          case \"left\":\n            x = 0;\n            break;\n          case \"center\":\n            x = 0.5;\n            break;\n          case \"right\":\n            x = 1;\n            break;\n          default:\n            x = origin[1] / original.width;\n        }\n        return {\n          x: x,\n          y: y\n        };\n      },\n      // Creates a placeholder element so that the original element can be made absolute\n      createPlaceholder: function (element) {\n        var placeholder,\n          cssPosition = element.css(\"position\"),\n          position = element.position();\n\n        // Lock in margins first to account for form elements, which\n        // will change margin if you explicitly set height\n        // see: https://jsfiddle.net/JZSMt/3/ https://bugs.webkit.org/show_bug.cgi?id=107380\n        // Support: Safari\n        element.css({\n          marginTop: element.css(\"marginTop\"),\n          marginBottom: element.css(\"marginBottom\"),\n          marginLeft: element.css(\"marginLeft\"),\n          marginRight: element.css(\"marginRight\")\n        }).outerWidth(element.outerWidth()).outerHeight(element.outerHeight());\n        if (/^(static|relative)/.test(cssPosition)) {\n          cssPosition = \"absolute\";\n          placeholder = $(\"<\" + element[0].nodeName + \">\").insertAfter(element).css({\n            // Convert inline to inline block to account for inline elements\n            // that turn to inline block based on content (like img)\n            display: /^(inline|ruby)/.test(element.css(\"display\")) ? \"inline-block\" : \"block\",\n            visibility: \"hidden\",\n            // Margins need to be set to account for margin collapse\n            marginTop: element.css(\"marginTop\"),\n            marginBottom: element.css(\"marginBottom\"),\n            marginLeft: element.css(\"marginLeft\"),\n            marginRight: element.css(\"marginRight\"),\n            \"float\": element.css(\"float\")\n          }).outerWidth(element.outerWidth()).outerHeight(element.outerHeight()).addClass(\"ui-effects-placeholder\");\n          element.data(dataSpace + \"placeholder\", placeholder);\n        }\n        element.css({\n          position: cssPosition,\n          left: position.left,\n          top: position.top\n        });\n        return placeholder;\n      },\n      removePlaceholder: function (element) {\n        var dataKey = dataSpace + \"placeholder\",\n          placeholder = element.data(dataKey);\n        if (placeholder) {\n          placeholder.remove();\n          element.removeData(dataKey);\n        }\n      },\n      // Removes a placeholder if it exists and restores\n      // properties that were modified during placeholder creation\n      cleanUp: function (element) {\n        $.effects.restoreStyle(element);\n        $.effects.removePlaceholder(element);\n      },\n      setTransition: function (element, list, factor, value) {\n        value = value || {};\n        $.each(list, function (i, x) {\n          var unit = element.cssUnit(x);\n          if (unit[0] > 0) {\n            value[x] = unit[0] * factor + unit[1];\n          }\n        });\n        return value;\n      }\n    });\n\n    // Return an effect options object for the given parameters:\n    function _normalizeArguments(effect, options, speed, callback) {\n      // Allow passing all options as the first parameter\n      if ($.isPlainObject(effect)) {\n        options = effect;\n        effect = effect.effect;\n      }\n\n      // Convert to an object\n      effect = {\n        effect: effect\n      };\n\n      // Catch (effect, null, ...)\n      if (options == null) {\n        options = {};\n      }\n\n      // Catch (effect, callback)\n      if (typeof options === \"function\") {\n        callback = options;\n        speed = null;\n        options = {};\n      }\n\n      // Catch (effect, speed, ?)\n      if (typeof options === \"number\" || $.fx.speeds[options]) {\n        callback = speed;\n        speed = options;\n        options = {};\n      }\n\n      // Catch (effect, options, callback)\n      if (typeof speed === \"function\") {\n        callback = speed;\n        speed = null;\n      }\n\n      // Add options to effect\n      if (options) {\n        $.extend(effect, options);\n      }\n      speed = speed || options.duration;\n      effect.duration = $.fx.off ? 0 : typeof speed === \"number\" ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;\n      effect.complete = callback || options.complete;\n      return effect;\n    }\n    function standardAnimationOption(option) {\n      // Valid standard speeds (nothing, number, named speed)\n      if (!option || typeof option === \"number\" || $.fx.speeds[option]) {\n        return true;\n      }\n\n      // Invalid strings - treat as \"normal\" speed\n      if (typeof option === \"string\" && !$.effects.effect[option]) {\n        return true;\n      }\n\n      // Complete callback\n      if (typeof option === \"function\") {\n        return true;\n      }\n\n      // Options hash (but not naming an effect)\n      if (typeof option === \"object\" && !option.effect) {\n        return true;\n      }\n\n      // Didn't match any standard API\n      return false;\n    }\n    $.fn.extend({\n      effect: function /* effect, options, speed, callback */\n      () {\n        var args = _normalizeArguments.apply(this, arguments),\n          effectMethod = $.effects.effect[args.effect],\n          defaultMode = effectMethod.mode,\n          queue = args.queue,\n          queueName = queue || \"fx\",\n          complete = args.complete,\n          mode = args.mode,\n          modes = [],\n          prefilter = function (next) {\n            var el = $(this),\n              normalizedMode = $.effects.mode(el, mode) || defaultMode;\n\n            // Sentinel for duck-punching the :animated pseudo-selector\n            el.data(dataSpaceAnimated, true);\n\n            // Save effect mode for later use,\n            // we can't just call $.effects.mode again later,\n            // as the .show() below destroys the initial state\n            modes.push(normalizedMode);\n\n            // See $.uiBackCompat inside of run() for removal of defaultMode in 1.14\n            if (defaultMode && (normalizedMode === \"show\" || normalizedMode === defaultMode && normalizedMode === \"hide\")) {\n              el.show();\n            }\n            if (!defaultMode || normalizedMode !== \"none\") {\n              $.effects.saveStyle(el);\n            }\n            if (typeof next === \"function\") {\n              next();\n            }\n          };\n        if ($.fx.off || !effectMethod) {\n          // Delegate to the original method (e.g., .show()) if possible\n          if (mode) {\n            return this[mode](args.duration, complete);\n          } else {\n            return this.each(function () {\n              if (complete) {\n                complete.call(this);\n              }\n            });\n          }\n        }\n        function run(next) {\n          var elem = $(this);\n          function cleanup() {\n            elem.removeData(dataSpaceAnimated);\n            $.effects.cleanUp(elem);\n            if (args.mode === \"hide\") {\n              elem.hide();\n            }\n            done();\n          }\n          function done() {\n            if (typeof complete === \"function\") {\n              complete.call(elem[0]);\n            }\n            if (typeof next === \"function\") {\n              next();\n            }\n          }\n\n          // Override mode option on a per element basis,\n          // as toggle can be either show or hide depending on element state\n          args.mode = modes.shift();\n          if ($.uiBackCompat !== false && !defaultMode) {\n            if (elem.is(\":hidden\") ? mode === \"hide\" : mode === \"show\") {\n              // Call the core method to track \"olddisplay\" properly\n              elem[mode]();\n              done();\n            } else {\n              effectMethod.call(elem[0], args, done);\n            }\n          } else {\n            if (args.mode === \"none\") {\n              // Call the core method to track \"olddisplay\" properly\n              elem[mode]();\n              done();\n            } else {\n              effectMethod.call(elem[0], args, cleanup);\n            }\n          }\n        }\n\n        // Run prefilter on all elements first to ensure that\n        // any showing or hiding happens before placeholder creation,\n        // which ensures that any layout changes are correctly captured.\n        return queue === false ? this.each(prefilter).each(run) : this.queue(queueName, prefilter).queue(queueName, run);\n      },\n      show: function (orig) {\n        return function (option) {\n          if (standardAnimationOption(option)) {\n            return orig.apply(this, arguments);\n          } else {\n            var args = _normalizeArguments.apply(this, arguments);\n            args.mode = \"show\";\n            return this.effect.call(this, args);\n          }\n        };\n      }($.fn.show),\n      hide: function (orig) {\n        return function (option) {\n          if (standardAnimationOption(option)) {\n            return orig.apply(this, arguments);\n          } else {\n            var args = _normalizeArguments.apply(this, arguments);\n            args.mode = \"hide\";\n            return this.effect.call(this, args);\n          }\n        };\n      }($.fn.hide),\n      toggle: function (orig) {\n        return function (option) {\n          if (standardAnimationOption(option) || typeof option === \"boolean\") {\n            return orig.apply(this, arguments);\n          } else {\n            var args = _normalizeArguments.apply(this, arguments);\n            args.mode = \"toggle\";\n            return this.effect.call(this, args);\n          }\n        };\n      }($.fn.toggle),\n      cssUnit: function (key) {\n        var style = this.css(key),\n          val = [];\n        $.each([\"em\", \"px\", \"%\", \"pt\"], function (i, unit) {\n          if (style.indexOf(unit) > 0) {\n            val = [parseFloat(style), unit];\n          }\n        });\n        return val;\n      },\n      cssClip: function (clipObj) {\n        if (clipObj) {\n          return this.css(\"clip\", \"rect(\" + clipObj.top + \"px \" + clipObj.right + \"px \" + clipObj.bottom + \"px \" + clipObj.left + \"px)\");\n        }\n        return parseClip(this.css(\"clip\"), this);\n      },\n      transfer: function (options, done) {\n        var element = $(this),\n          target = $(options.to),\n          targetFixed = target.css(\"position\") === \"fixed\",\n          body = $(\"body\"),\n          fixTop = targetFixed ? body.scrollTop() : 0,\n          fixLeft = targetFixed ? body.scrollLeft() : 0,\n          endPosition = target.offset(),\n          animation = {\n            top: endPosition.top - fixTop,\n            left: endPosition.left - fixLeft,\n            height: target.innerHeight(),\n            width: target.innerWidth()\n          },\n          startPosition = element.offset(),\n          transfer = $(\"<div class='ui-effects-transfer'></div>\");\n        transfer.appendTo(\"body\").addClass(options.className).css({\n          top: startPosition.top - fixTop,\n          left: startPosition.left - fixLeft,\n          height: element.innerHeight(),\n          width: element.innerWidth(),\n          position: targetFixed ? \"fixed\" : \"absolute\"\n        }).animate(animation, options.duration, options.easing, function () {\n          transfer.remove();\n          if (typeof done === \"function\") {\n            done();\n          }\n        });\n      }\n    });\n    function parseClip(str, element) {\n      var outerWidth = element.outerWidth(),\n        outerHeight = element.outerHeight(),\n        clipRegex = /^rect\\((-?\\d*\\.?\\d*px|-?\\d+%|auto),?\\s*(-?\\d*\\.?\\d*px|-?\\d+%|auto),?\\s*(-?\\d*\\.?\\d*px|-?\\d+%|auto),?\\s*(-?\\d*\\.?\\d*px|-?\\d+%|auto)\\)$/,\n        values = clipRegex.exec(str) || [\"\", 0, outerWidth, outerHeight, 0];\n      return {\n        top: parseFloat(values[1]) || 0,\n        right: values[2] === \"auto\" ? outerWidth : parseFloat(values[2]),\n        bottom: values[3] === \"auto\" ? outerHeight : parseFloat(values[3]),\n        left: parseFloat(values[4]) || 0\n      };\n    }\n    $.fx.step.clip = function (fx) {\n      if (!fx.clipInit) {\n        fx.start = $(fx.elem).cssClip();\n        if (typeof fx.end === \"string\") {\n          fx.end = parseClip(fx.end, fx.elem);\n        }\n        fx.clipInit = true;\n      }\n      $(fx.elem).cssClip({\n        top: fx.pos * (fx.end.top - fx.start.top) + fx.start.top,\n        right: fx.pos * (fx.end.right - fx.start.right) + fx.start.right,\n        bottom: fx.pos * (fx.end.bottom - fx.start.bottom) + fx.start.bottom,\n        left: fx.pos * (fx.end.left - fx.start.left) + fx.start.left\n      });\n    };\n  })();\n\n  /******************************************************************************/\n  /*********************************** EASING ***********************************/\n  /******************************************************************************/\n\n  (function () {\n    // Based on easing equations from Robert Penner (http://robertpenner.com/easing)\n\n    var baseEasings = {};\n    $.each([\"Quad\", \"Cubic\", \"Quart\", \"Quint\", \"Expo\"], function (i, name) {\n      baseEasings[name] = function (p) {\n        return Math.pow(p, i + 2);\n      };\n    });\n    $.extend(baseEasings, {\n      Sine: function (p) {\n        return 1 - Math.cos(p * Math.PI / 2);\n      },\n      Circ: function (p) {\n        return 1 - Math.sqrt(1 - p * p);\n      },\n      Elastic: function (p) {\n        return p === 0 || p === 1 ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);\n      },\n      Back: function (p) {\n        return p * p * (3 * p - 2);\n      },\n      Bounce: function (p) {\n        var pow2,\n          bounce = 4;\n        while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {}\n        return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);\n      }\n    });\n    $.each(baseEasings, function (name, easeIn) {\n      $.easing[\"easeIn\" + name] = easeIn;\n      $.easing[\"easeOut\" + name] = function (p) {\n        return 1 - easeIn(1 - p);\n      };\n      $.easing[\"easeInOut\" + name] = function (p) {\n        return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn(p * -2 + 2) / 2;\n      };\n    });\n  })();\n  return $.effects;\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}